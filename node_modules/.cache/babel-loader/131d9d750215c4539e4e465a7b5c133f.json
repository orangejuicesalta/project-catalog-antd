{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/web.timers.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\nimport omit from '../_util/omit';\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nvar AffixStatus;\n\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {})); // Affix\n\n\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      \"default\": getDefaultTarget\n    },\n    prefixCls: String,\n\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  name: 'AAffix',\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n        emit = _ref.emit,\n        expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n\n    var measure = function measure() {\n      var status = state.status,\n          lastAffix = state.lastAffix;\n      var target = props.target;\n\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n\n      var targetNode = target();\n\n      if (!targetNode) {\n        return;\n      }\n\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      } // update state\n\n\n      _extends(state, newState);\n    };\n\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n\n      currentInstance.update(); // Test if `updatePosition` called\n\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle; // Check position change before measure to make Safari smooth\n\n      if (target && affixStyle) {\n        var targetNode = target();\n\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      } // Directly call prepare measure since it's already throttled.\n\n\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance); // Mock Event object.\n\n          updatePosition();\n        }\n\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance); // Mock Event object.\n\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel(); // https://github.com/ant-design/ant-design/issues/22683\n\n      lazyUpdatePosition.cancel();\n    });\n\n    var _useConfigInject = useConfigInject('affix', props),\n        prefixCls = _useConfigInject.prefixCls;\n\n    return function () {\n      var _a;\n\n      var affixStyle = state.affixStyle,\n          placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        \"default\": function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots[\"default\"]) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);","map":{"version":3,"names":["_objectSpread","_defineProperty","_extends","createVNode","_createVNode","defineComponent","ref","reactive","watch","onMounted","getCurrentInstance","computed","onUnmounted","onUpdated","classNames","ResizeObserver","throttleByAnimationFrame","withInstall","addObserveTarget","removeObserveTarget","getTargetRect","getFixedTop","getFixedBottom","useConfigInject","omit","getDefaultTarget","window","AffixStatus","affixProps","offsetTop","Number","offsetBottom","target","type","Function","prefixCls","String","onChange","onTestUpdatePosition","Affix","name","props","setup","_ref","slots","emit","expose","placeholderNode","fixedNode","state","affixStyle","undefined","placeholderStyle","status","None","lastAffix","prevTarget","timeout","currentInstance","measure","Prepare","value","targetNode","newState","targetRect","placeholderReact","fixedTop","fixedBottom","position","top","width","height","bottom","prepareMeasure","update","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","val","newTarget","setTimeout","clearTimeout","cancel","_useConfigInject","_a","className","restProps","_default","call"],"sources":["/home/orange/Desktop/project-catalog-antd/node_modules/ant-design-vue/es/affix/index.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { defineComponent, ref, reactive, watch, onMounted, getCurrentInstance, computed, onUnmounted, onUpdated } from 'vue';\nimport classNames from '../_util/classNames';\nimport ResizeObserver from '../vc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { withInstall } from '../_util/type';\nimport { addObserveTarget, removeObserveTarget, getTargetRect, getFixedTop, getFixedBottom } from './utils';\nimport useConfigInject from '../_util/hooks/useConfigInject';\nimport omit from '../_util/omit';\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nvar AffixStatus;\n\n(function (AffixStatus) {\n  AffixStatus[AffixStatus[\"None\"] = 0] = \"None\";\n  AffixStatus[AffixStatus[\"Prepare\"] = 1] = \"Prepare\";\n})(AffixStatus || (AffixStatus = {})); // Affix\n\n\nexport var affixProps = function affixProps() {\n  return {\n    /**\n     * 距离窗口顶部达到指定偏移量后触发\n     */\n    offsetTop: Number,\n\n    /** 距离窗口底部达到指定偏移量后触发 */\n    offsetBottom: Number,\n\n    /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */\n    target: {\n      type: Function,\n      default: getDefaultTarget\n    },\n    prefixCls: String,\n\n    /** 固定状态改变时触发的回调函数 */\n    onChange: Function,\n    onTestUpdatePosition: Function\n  };\n};\nvar Affix = defineComponent({\n  name: 'AAffix',\n  props: affixProps(),\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots,\n        emit = _ref.emit,\n        expose = _ref.expose;\n    var placeholderNode = ref();\n    var fixedNode = ref();\n    var state = reactive({\n      affixStyle: undefined,\n      placeholderStyle: undefined,\n      status: AffixStatus.None,\n      lastAffix: false,\n      prevTarget: null,\n      timeout: null\n    });\n    var currentInstance = getCurrentInstance();\n    var offsetTop = computed(function () {\n      return props.offsetBottom === undefined && props.offsetTop === undefined ? 0 : props.offsetTop;\n    });\n    var offsetBottom = computed(function () {\n      return props.offsetBottom;\n    });\n\n    var measure = function measure() {\n      var status = state.status,\n          lastAffix = state.lastAffix;\n      var target = props.target;\n\n      if (status !== AffixStatus.Prepare || !fixedNode.value || !placeholderNode.value || !target) {\n        return;\n      }\n\n      var targetNode = target();\n\n      if (!targetNode) {\n        return;\n      }\n\n      var newState = {\n        status: AffixStatus.None\n      };\n      var targetRect = getTargetRect(targetNode);\n      var placeholderReact = getTargetRect(placeholderNode.value);\n      var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n      var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n        newState.placeholderStyle = {\n          width: placeholderReact.width + 'px',\n          height: placeholderReact.height + 'px'\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        emit('change', newState.lastAffix);\n      } // update state\n\n\n      _extends(state, newState);\n    };\n\n    var prepareMeasure = function prepareMeasure() {\n      _extends(state, {\n        status: AffixStatus.Prepare,\n        affixStyle: undefined,\n        placeholderStyle: undefined\n      });\n\n      currentInstance.update(); // Test if `updatePosition` called\n\n      if (process.env.NODE_ENV === 'test') {\n        emit('testUpdatePosition');\n      }\n    };\n\n    var updatePosition = throttleByAnimationFrame(function () {\n      prepareMeasure();\n    });\n    var lazyUpdatePosition = throttleByAnimationFrame(function () {\n      var target = props.target;\n      var affixStyle = state.affixStyle; // Check position change before measure to make Safari smooth\n\n      if (target && affixStyle) {\n        var targetNode = target();\n\n        if (targetNode && placeholderNode.value) {\n          var targetRect = getTargetRect(targetNode);\n          var placeholderReact = getTargetRect(placeholderNode.value);\n          var fixedTop = getFixedTop(placeholderReact, targetRect, offsetTop.value);\n          var fixedBottom = getFixedBottom(placeholderReact, targetRect, offsetBottom.value);\n\n          if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n            return;\n          }\n        }\n      } // Directly call prepare measure since it's already throttled.\n\n\n      prepareMeasure();\n    });\n    expose({\n      updatePosition: updatePosition,\n      lazyUpdatePosition: lazyUpdatePosition\n    });\n    watch(function () {\n      return props.target;\n    }, function (val) {\n      var newTarget = (val === null || val === void 0 ? void 0 : val()) || null;\n\n      if (state.prevTarget !== newTarget) {\n        removeObserveTarget(currentInstance);\n\n        if (newTarget) {\n          addObserveTarget(newTarget, currentInstance); // Mock Event object.\n\n          updatePosition();\n        }\n\n        state.prevTarget = newTarget;\n      }\n    });\n    watch(function () {\n      return [props.offsetTop, props.offsetBottom];\n    }, updatePosition);\n    onMounted(function () {\n      var target = props.target;\n\n      if (target) {\n        // [Legacy] Wait for parent component ref has its value.\n        // We should use target as directly element instead of function which makes element check hard.\n        state.timeout = setTimeout(function () {\n          addObserveTarget(target(), currentInstance); // Mock Event object.\n\n          updatePosition();\n        });\n      }\n    });\n    onUpdated(function () {\n      measure();\n    });\n    onUnmounted(function () {\n      clearTimeout(state.timeout);\n      removeObserveTarget(currentInstance);\n      updatePosition.cancel(); // https://github.com/ant-design/ant-design/issues/22683\n\n      lazyUpdatePosition.cancel();\n    });\n\n    var _useConfigInject = useConfigInject('affix', props),\n        prefixCls = _useConfigInject.prefixCls;\n\n    return function () {\n      var _a;\n\n      var affixStyle = state.affixStyle,\n          placeholderStyle = state.placeholderStyle;\n      var className = classNames(_defineProperty({}, prefixCls.value, affixStyle));\n      var restProps = omit(props, ['prefixCls', 'offsetTop', 'offsetBottom', 'target', 'onChange', 'onTestUpdatePosition']);\n      return _createVNode(ResizeObserver, {\n        \"onResize\": updatePosition\n      }, {\n        default: function _default() {\n          return [_createVNode(\"div\", _objectSpread(_objectSpread({}, restProps), {}, {\n            \"style\": placeholderStyle,\n            \"ref\": placeholderNode\n          }), [_createVNode(\"div\", {\n            \"class\": className,\n            \"ref\": fixedNode,\n            \"style\": affixStyle\n          }, [(_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)])])];\n        }\n      });\n    };\n  }\n});\nexport default withInstall(Affix);"],"mappings":"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"},"metadata":{},"sourceType":"module"}