{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/home/orange/Desktop/project-catalog-antd/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nvar _toConsumableArray = require(\"/home/orange/Desktop/project-catalog-antd/node_modules/@babel/runtime/helpers/toConsumableArray.js\")[\"default\"];\n\nvar _typeof = require(\"/home/orange/Desktop/project-catalog-antd/node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.object.define-property.js\");\n\nrequire(\"core-js/modules/es.array.is-array.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.index-of.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.json.stringify.js\");\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/es.array.join.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-names.js\");\n\nrequire(\"core-js/modules/es.array.for-each.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.assertEach = assertEach;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertNodeType = assertNodeType;\nexports.assertOneOf = assertOneOf;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.assertShape = assertShape;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports[\"default\"] = defineType;\nexports.defineAliasedType = defineAliasedType;\nexports.typeIs = typeIs;\nexports.validate = validate;\nexports.validateArrayOfType = validateArrayOfType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.validateType = validateType;\n\nvar _is = require(\"../validators/is\");\n\nvar _validate = require(\"../validators/validate\");\n\nvar VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nvar ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nvar FLIPPED_ALIAS_KEYS = {};\nexports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\nvar NODE_FIELDS = {};\nexports.NODE_FIELDS = NODE_FIELDS;\nvar BUILDER_KEYS = {};\nexports.BUILDER_KEYS = BUILDER_KEYS;\nvar DEPRECATED_KEYS = {};\nexports.DEPRECATED_KEYS = DEPRECATED_KEYS;\nvar NODE_PARENT_VALIDATIONS = {};\nexports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;\n\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return _typeof(val);\n  }\n}\n\nfunction validate(validate) {\n  return {\n    validate: validate\n  };\n}\n\nfunction typeIs(typeName) {\n  return typeof typeName === \"string\" ? assertNodeType(typeName) : assertNodeType.apply(void 0, _toConsumableArray(typeName));\n}\n\nfunction validateType(typeName) {\n  return validate(typeIs(typeName));\n}\n\nfunction validateOptional(validate) {\n  return {\n    validate: validate,\n    optional: true\n  };\n}\n\nfunction validateOptionalType(typeName) {\n  return {\n    validate: typeIs(typeName),\n    optional: true\n  };\n}\n\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nfunction arrayOfType(typeName) {\n  return arrayOf(typeIs(typeName));\n}\n\nfunction validateArrayOfType(typeName) {\n  return validate(arrayOfType(typeName));\n}\n\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n\n    for (var i = 0; i < val.length; i++) {\n      var subkey = \"\".concat(key, \"[\").concat(i, \"]\");\n      var v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);\n    }\n  }\n\n  validator.each = callback;\n  return validator;\n}\n\nfunction assertOneOf() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  function validate(node, key, val) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(\"Property \".concat(key, \" expected value to be one of \").concat(JSON.stringify(values), \" but got \").concat(JSON.stringify(val)));\n    }\n  }\n\n  validate.oneOf = values;\n  return validate;\n}\n\nfunction assertNodeType() {\n  for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    types[_key2] = arguments[_key2];\n  }\n\n  function validate(node, key, val) {\n    var _iterator = _createForOfIteratorHelper(types),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n\n        if ((0, _is[\"default\"])(type, val)) {\n          (0, _validate.validateChild)(node, key, val);\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    throw new TypeError(\"Property \".concat(key, \" of \").concat(node.type, \" expected node to be of a type \").concat(JSON.stringify(types), \" but instead got \").concat(JSON.stringify(val == null ? void 0 : val.type)));\n  }\n\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\n\nfunction assertNodeOrValueType() {\n  for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    types[_key3] = arguments[_key3];\n  }\n\n  function validate(node, key, val) {\n    var _iterator2 = _createForOfIteratorHelper(types),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var type = _step2.value;\n\n        if (getType(val) === type || (0, _is[\"default\"])(type, val)) {\n          (0, _validate.validateChild)(node, key, val);\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    throw new TypeError(\"Property \".concat(key, \" of \").concat(node.type, \" expected node to be of a type \").concat(JSON.stringify(types), \" but instead got \").concat(JSON.stringify(val == null ? void 0 : val.type)));\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\n\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    var valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\"Property \".concat(key, \" expected type of \").concat(type, \" but got \").concat(getType(val)));\n    }\n  }\n\n  validate.type = type;\n  return validate;\n}\n\nfunction assertShape(shape) {\n  function validate(node, key, val) {\n    var errors = [];\n\n    for (var _i = 0, _Object$keys = Object.keys(shape); _i < _Object$keys.length; _i++) {\n      var property = _Object$keys[_i];\n\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n\n        throw error;\n      }\n    }\n\n    if (errors.length) {\n      throw new TypeError(\"Property \".concat(key, \" of \").concat(node.type, \" expected to have the following:\\n\").concat(errors.join(\"\\n\")));\n    }\n  }\n\n  validate.shapeOf = shape;\n  return validate;\n}\n\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n\n    var current = node;\n\n    while (node) {\n      var _current2 = current,\n          type = _current2.type;\n\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(\"Non-optional \".concat(node.type, \" must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from \").concat((_current = current) == null ? void 0 : _current.type));\n  }\n\n  return validate;\n}\n\nfunction chain() {\n  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    fns[_key4] = arguments[_key4];\n  }\n\n  function validate() {\n    var _iterator3 = _createForOfIteratorHelper(fns),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var fn = _step3.value;\n        fn.apply(void 0, arguments);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  validate.chainOf = fns;\n\n  if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n    throw new Error(\"An assertValueType(\\\"array\\\") validator can only be followed by an assertEach(...) validator.\");\n  }\n\n  return validate;\n}\n\nvar validTypeOpts = [\"aliases\", \"builder\", \"deprecatedAlias\", \"fields\", \"inherits\", \"visitor\", \"validate\"];\nvar validFieldKeys = [\"default\", \"optional\", \"validate\"];\n\nfunction defineAliasedType() {\n  for (var _len5 = arguments.length, aliases = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    aliases[_key5] = arguments[_key5];\n  }\n\n  return function (type) {\n    var _defined2;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var defined = opts.aliases;\n\n    if (!defined) {\n      var _store$opts$inherits$, _defined;\n\n      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();\n      (_defined = defined) != null ? _defined : defined = [];\n      opts.aliases = defined;\n    }\n\n    var additional = aliases.filter(function (a) {\n      return !defined.includes(a);\n    });\n\n    (_defined2 = defined).unshift.apply(_defined2, _toConsumableArray(additional));\n\n    return defineType(type, opts);\n  };\n}\n\nfunction defineType(type) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var inherits = opts.inherits && store[opts.inherits] || {};\n  var fields = opts.fields;\n\n  if (!fields) {\n    fields = {};\n\n    if (inherits.fields) {\n      var keys = Object.getOwnPropertyNames(inherits.fields);\n\n      var _iterator4 = _createForOfIteratorHelper(keys),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var key = _step4.value;\n          var field = inherits.fields[key];\n          var def = field[\"default\"];\n\n          if (Array.isArray(def) ? def.length > 0 : def && _typeof(def) === \"object\") {\n            throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n          }\n\n          fields[key] = {\n            \"default\": Array.isArray(def) ? [] : def,\n            optional: field.optional,\n            validate: field.validate\n          };\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }\n\n  var visitor = opts.visitor || inherits.visitor || [];\n  var aliases = opts.aliases || inherits.aliases || [];\n  var builder = opts.builder || inherits.builder || opts.visitor || [];\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(opts); _i2 < _Object$keys2.length; _i2++) {\n    var k = _Object$keys2[_i2];\n\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(\"Unknown type option \\\"\".concat(k, \"\\\" on \").concat(type));\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(visitor.concat(builder)),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _key7 = _step5.value;\n      fields[_key7] = fields[_key7] || {};\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  for (var _i3 = 0, _Object$keys3 = Object.keys(fields); _i3 < _Object$keys3.length; _i3++) {\n    var _key6 = _Object$keys3[_i3];\n    var _field = fields[_key6];\n\n    if (_field[\"default\"] !== undefined && builder.indexOf(_key6) === -1) {\n      _field.optional = true;\n    }\n\n    if (_field[\"default\"] === undefined) {\n      _field[\"default\"] = null;\n    } else if (!_field.validate && _field[\"default\"] != null) {\n      _field.validate = assertValueType(getType(_field[\"default\"]));\n    }\n\n    for (var _i4 = 0, _Object$keys4 = Object.keys(_field); _i4 < _Object$keys4.length; _i4++) {\n      var _k = _Object$keys4[_i4];\n\n      if (validFieldKeys.indexOf(_k) === -1) {\n        throw new Error(\"Unknown field key \\\"\".concat(_k, \"\\\" on \").concat(type, \".\").concat(_key6));\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(function (alias) {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n\n  store[type] = opts;\n}\n\nvar store = {};","map":{"version":3,"names":["Object","defineProperty","exports","value","VISITOR_KEYS","NODE_PARENT_VALIDATIONS","NODE_FIELDS","FLIPPED_ALIAS_KEYS","DEPRECATED_KEYS","BUILDER_KEYS","ALIAS_KEYS","arrayOf","arrayOfType","assertEach","assertNodeOrValueType","assertNodeType","assertOneOf","assertOptionalChainStart","assertShape","assertValueType","chain","defineType","defineAliasedType","typeIs","validate","validateArrayOfType","validateOptional","validateOptionalType","validateType","_is","require","_validate","getType","val","Array","isArray","typeName","optional","elementType","callback","validator","node","key","i","length","subkey","v","process","env","BABEL_TYPES_8_BREAKING","validateChild","each","values","indexOf","TypeError","JSON","stringify","oneOf","types","type","oneOfNodeTypes","oneOfNodeOrValueTypes","valid","shape","errors","keys","property","validateField","error","push","message","join","shapeOf","_current","current","callee","object","fns","fn","chainOf","Error","validTypeOpts","validFieldKeys","aliases","opts","defined","_store$opts$inherits$","_defined","inherits","store","slice","additional","filter","a","includes","unshift","fields","getOwnPropertyNames","field","def","visitor","builder","k","deprecatedAlias","concat","undefined","forEach","alias"],"sources":["/home/orange/Desktop/project-catalog-antd/node_modules/@babel/types/lib/definitions/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.assertEach = assertEach;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertNodeType = assertNodeType;\nexports.assertOneOf = assertOneOf;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.assertShape = assertShape;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports.default = defineType;\nexports.defineAliasedType = defineAliasedType;\nexports.typeIs = typeIs;\nexports.validate = validate;\nexports.validateArrayOfType = validateArrayOfType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.validateType = validateType;\n\nvar _is = require(\"../validators/is\");\n\nvar _validate = require(\"../validators/validate\");\n\nconst VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nconst ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nconst FLIPPED_ALIAS_KEYS = {};\nexports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\nconst NODE_FIELDS = {};\nexports.NODE_FIELDS = NODE_FIELDS;\nconst BUILDER_KEYS = {};\nexports.BUILDER_KEYS = BUILDER_KEYS;\nconst DEPRECATED_KEYS = {};\nexports.DEPRECATED_KEYS = DEPRECATED_KEYS;\nconst NODE_PARENT_VALIDATIONS = {};\nexports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;\n\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\n\nfunction validate(validate) {\n  return {\n    validate\n  };\n}\n\nfunction typeIs(typeName) {\n  return typeof typeName === \"string\" ? assertNodeType(typeName) : assertNodeType(...typeName);\n}\n\nfunction validateType(typeName) {\n  return validate(typeIs(typeName));\n}\n\nfunction validateOptional(validate) {\n  return {\n    validate,\n    optional: true\n  };\n}\n\nfunction validateOptionalType(typeName) {\n  return {\n    validate: typeIs(typeName),\n    optional: true\n  };\n}\n\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nfunction arrayOfType(typeName) {\n  return arrayOf(typeIs(typeName));\n}\n\nfunction validateArrayOfType(typeName) {\n  return validate(arrayOfType(typeName));\n}\n\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);\n    }\n  }\n\n  validator.each = callback;\n  return validator;\n}\n\nfunction assertOneOf(...values) {\n  function validate(node, key, val) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);\n    }\n  }\n\n  validate.oneOf = values;\n  return validate;\n}\n\nfunction assertNodeType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if ((0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\n\nfunction assertNodeOrValueType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if (getType(val) === type || (0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\n\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    const valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);\n    }\n  }\n\n  validate.type = type;\n  return validate;\n}\n\nfunction assertShape(shape) {\n  function validate(node, key, val) {\n    const errors = [];\n\n    for (const property of Object.keys(shape)) {\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n\n        throw error;\n      }\n    }\n\n    if (errors.length) {\n      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\\n${errors.join(\"\\n\")}`);\n    }\n  }\n\n  validate.shapeOf = shape;\n  return validate;\n}\n\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n\n    let current = node;\n\n    while (node) {\n      const {\n        type\n      } = current;\n\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);\n  }\n\n  return validate;\n}\n\nfunction chain(...fns) {\n  function validate(...args) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n\n  validate.chainOf = fns;\n\n  if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n    throw new Error(`An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`);\n  }\n\n  return validate;\n}\n\nconst validTypeOpts = [\"aliases\", \"builder\", \"deprecatedAlias\", \"fields\", \"inherits\", \"visitor\", \"validate\"];\nconst validFieldKeys = [\"default\", \"optional\", \"validate\"];\n\nfunction defineAliasedType(...aliases) {\n  return (type, opts = {}) => {\n    let defined = opts.aliases;\n\n    if (!defined) {\n      var _store$opts$inherits$, _defined;\n\n      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();\n      (_defined = defined) != null ? _defined : defined = [];\n      opts.aliases = defined;\n    }\n\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    return defineType(type, opts);\n  };\n}\n\nfunction defineType(type, opts = {}) {\n  const inherits = opts.inherits && store[opts.inherits] || {};\n  let fields = opts.fields;\n\n  if (!fields) {\n    fields = {};\n\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n\n        if (Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\") {\n          throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n        }\n\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          validate: field.validate\n        };\n      }\n    }\n  }\n\n  const visitor = opts.visitor || inherits.visitor || [];\n  const aliases = opts.aliases || inherits.aliases || [];\n  const builder = opts.builder || inherits.builder || opts.visitor || [];\n\n  for (const k of Object.keys(opts)) {\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n\n    if (field.default !== undefined && builder.indexOf(key) === -1) {\n      field.optional = true;\n    }\n\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n\n    for (const k of Object.keys(field)) {\n      if (validFieldKeys.indexOf(k) === -1) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n\n  store[type] = opts;\n}\n\nconst store = {};"],"mappings":"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"},"metadata":{},"sourceType":"script"}