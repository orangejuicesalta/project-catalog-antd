{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/orange/Desktop/project-catalog-antd/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _createForOfIteratorHelper = require(\"/home/orange/Desktop/project-catalog-antd/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\")[\"default\"];\n\nvar _toConsumableArray = require(\"/home/orange/Desktop/project-catalog-antd/node_modules/@babel/runtime/helpers/toConsumableArray.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.object.define-property.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.array.index-of.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = removeTypeDuplicates;\n\nvar _generated = require(\"../../validators/generated\");\n\nfunction getQualifiedName(node) {\n  return (0, _generated.isIdentifier)(node) ? node.name : \"\".concat(node.right.name, \".\").concat(getQualifiedName(node.left));\n}\n\nfunction removeTypeDuplicates(nodes) {\n  var generics = new Map();\n  var bases = new Map();\n  var typeGroups = new Set();\n  var types = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isTSAnyKeyword)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isTSBaseType)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if ((0, _generated.isTSUnionType)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push.apply(nodes, _toConsumableArray(node.types));\n        typeGroups.add(node.types);\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {\n      var name = getQualifiedName(node.typeName);\n\n      if (generics.has(name)) {\n        var existing = generics.get(name);\n\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  var _iterator = _createForOfIteratorHelper(bases),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          baseType = _step$value[1];\n\n      types.push(baseType);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(generics),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n          genericName = _step2$value[1];\n\n      types.push(genericName);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return types;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","removeTypeDuplicates","_generated","require","getQualifiedName","node","isIdentifier","name","right","left","nodes","generics","Map","bases","typeGroups","Set","types","i","length","indexOf","isTSAnyKeyword","isTSBaseType","set","type","isTSUnionType","has","push","add","isTSTypeReference","typeParameters","typeName","existing","get","params","concat","baseType","genericName"],"sources":["/home/orange/Desktop/project-catalog-antd/node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = removeTypeDuplicates;\n\nvar _generated = require(\"../../validators/generated\");\n\nfunction getQualifiedName(node) {\n  return (0, _generated.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\n\nfunction removeTypeDuplicates(nodes) {\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    if ((0, _generated.isTSAnyKeyword)(node)) {\n      return [node];\n    }\n\n    if ((0, _generated.isTSBaseType)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if ((0, _generated.isTSUnionType)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n\n      continue;\n    }\n\n    if ((0, _generated.isTSTypeReference)(node) && node.typeParameters) {\n      const name = getQualifiedName(node.typeName);\n\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}