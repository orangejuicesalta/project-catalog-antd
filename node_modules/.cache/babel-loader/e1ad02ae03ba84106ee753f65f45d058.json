{"ast":null,"code":"import \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.array.every.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.some.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.reverse.js\";\nimport \"core-js/modules/es.parse-float.js\";\nimport \"core-js/modules/es.array.sort.js\";\nimport \"core-js/modules/es.array.index-of.js\";\nimport \"core-js/modules/es.array.slice.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nimport initDefaultProps from '../../_util/props-util/initDefaultProps';\nimport { defineComponent } from 'vue';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: Number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: {\n    type: Boolean,\n    \"default\": undefined\n  },\n  disabled: {\n    type: Boolean,\n    \"default\": undefined\n  },\n  reverse: {\n    type: Boolean,\n    \"default\": undefined\n  },\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: String,\n  min: Number,\n  max: Number,\n  autofocus: {\n    type: Boolean,\n    \"default\": undefined\n  },\n  ariaLabelGroupForHandles: Array,\n  ariaLabelledByGroupForHandles: Array,\n  ariaValueTextFormatterGroupForHandles: Array,\n  draggableTrack: {\n    type: Boolean,\n    \"default\": undefined\n  }\n};\nvar Range = defineComponent({\n  name: 'Range',\n  mixins: [BaseMixin],\n  inheritAttrs: false,\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: [],\n    draggableTrack: false,\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  }),\n  emits: ['beforeChange', 'afterChange', 'change'],\n  displayName: 'Range',\n  data: function data() {\n    var _this = this;\n\n    var count = this.count,\n        min = this.min,\n        max = this.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    var value = this.value;\n\n    if (value === undefined) {\n      value = defaultValue;\n    }\n\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: _this.$props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent: recent,\n      bounds: bounds\n    };\n  },\n  watch: {\n    value: {\n      handler: function handler(val) {\n        var bounds = this.bounds;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min: function min() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    },\n    max: function max() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue: function setChangeValue(value) {\n      var _this2 = this;\n\n      var bounds = this.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: bounds,\n          props: _this2.$props\n        });\n      });\n\n      if (bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: _this2.$props\n          });\n        });\n      }\n\n      this.setState({\n        bounds: nextBounds\n      });\n\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.$props);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.$props);\n        });\n        this.$emit('change', newValues);\n      }\n    },\n    onChange: function onChange(state) {\n      var isNotControlled = !hasProp(this, 'value');\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['sHandle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _extends(_extends({}, this.$data), state);\n\n      var changedValue = data.bounds;\n      this.$emit('change', changedValue);\n    },\n    positionGetValue: function positionGetValue(position) {\n      var bounds = this.getValue();\n      var value = this.calcValueByPos(position);\n      var closestBound = this.getClosestBound(value);\n      var index = this.getBoundNeedMoving(value, closestBound);\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[index] = value;\n      return nextBounds;\n    },\n    onStart: function onStart(position) {\n      var bounds = this.bounds;\n      this.$emit('beforeChange', bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd: function onEnd(force) {\n      var sHandle = this.sHandle;\n      this.removeDocumentEvents();\n\n      if (!sHandle) {\n        this.dragTrack = false;\n      }\n\n      if (sHandle !== null || force) {\n        this.$emit('afterChange', this.bounds);\n      }\n\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.$data,\n          props = this.$props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n\n        return;\n      }\n\n      var bounds = this.bounds,\n          sHandle = this.sHandle;\n      var value = this.calcValueByPos(position);\n      var oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard: function onKeyboard(e) {\n      var _this$$props = this.$props,\n          reverse = _this$$props.reverse,\n          vertical = _this$$props.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var bounds = this.bounds,\n            sHandle = this.sHandle;\n        var oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        var mutatedValue = valueMutator(oldValue, this.$props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds: bounds,\n          props: this.$props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound: function getClosestBound(value) {\n      var bounds = this.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    },\n    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {\n      var bounds = this.bounds,\n          recent = this.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    },\n    getLowerBound: function getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound: function getUpperBound() {\n      var bounds = this.bounds;\n      return bounds[bounds.length - 1];\n    },\n\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints: function getPoints() {\n      var marks = this.marks,\n          step = this.step,\n          min = this.min,\n          max = this.max;\n      var cache = this.internalPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this.internalPointsCache.points;\n    },\n    moveTo: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var nextBounds = _toConsumableArray(this.bounds);\n\n      var sHandle = this.sHandle,\n          recent = this.recent;\n      var handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.$emit('afterChange', nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    },\n    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n\n\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue: function trimAlignValue(value) {\n      var sHandle = this.sHandle,\n          bounds = this.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: sHandle,\n        bounds: bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {\n      var allowCross = _ref2.allowCross,\n          thershold = _ref2.pushable;\n      var state = this.$data || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n\n\n      return val;\n    },\n    getTrack: function getTrack(_ref3) {\n      var bounds = _ref3.bounds,\n          prefixCls = _ref3.prefixCls,\n          reverse = _ref3.reverse,\n          vertical = _ref3.vertical,\n          included = _ref3.included,\n          offsets = _ref3.offsets,\n          trackStyle = _ref3.trackStyle;\n      return bounds.slice(0, -1).map(function (_, index) {\n        var _classNames;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames));\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider: function renderSlider() {\n      var _this4 = this;\n\n      var sHandle = this.sHandle,\n          bounds = this.bounds,\n          prefixCls = this.prefixCls,\n          vertical = this.vertical,\n          included = this.included,\n          disabled = this.disabled,\n          min = this.min,\n          max = this.max,\n          reverse = this.reverse,\n          handle = this.handle,\n          defaultHandle = this.defaultHandle,\n          trackStyle = this.trackStyle,\n          handleStyle = this.handleStyle,\n          tabindex = this.tabindex,\n          ariaLabelGroupForHandles = this.ariaLabelGroupForHandles,\n          ariaLabelledByGroupForHandles = this.ariaLabelledByGroupForHandles,\n          ariaValueTextFormatterGroupForHandles = this.ariaValueTextFormatterGroupForHandles;\n      var handleGenerator = handle || defaultHandle;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames2;\n\n        var mergedTabIndex = tabindex[i] || 0;\n\n        if (disabled || tabindex[i] === null) {\n          mergedTabIndex = null;\n        }\n\n        var dragging = sHandle === i;\n        return handleGenerator({\n          \"class\": classNames((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames2)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabindex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          onFocus: _this4.onFocus,\n          onBlur: _this4.onBlur,\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds: bounds,\n          prefixCls: prefixCls,\n          reverse: reverse,\n          vertical: vertical,\n          included: included,\n          offsets: offsets,\n          trackStyle: trackStyle\n        }),\n        handles: handles\n      };\n    }\n  }\n});\nexport default createSlider(Range);","map":{"version":3,"names":["_defineProperty","_extends","_toConsumableArray","createVNode","_createVNode","classNames","PropTypes","withUndefined","BaseMixin","hasProp","Track","createSlider","utils","initDefaultProps","defineComponent","_trimAlignValue","trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","rangeProps","defaultValue","arrayOf","number","count","oneOfType","looseBool","type","Boolean","disabled","reverse","tabindex","prefixCls","String","min","max","autofocus","ariaLabelGroupForHandles","Array","ariaLabelledByGroupForHandles","ariaValueTextFormatterGroupForHandles","draggableTrack","Range","name","mixins","inheritAttrs","emits","displayName","data","_this","initialValue","apply","map","v","i","$props","recent","sHandle","watch","handler","val","setChangeValue","deep","methods","_this2","nextBounds","every","setState","some","isValueOutOfRange","newValues","$emit","onChange","state","isNotControlled","controlledState","forEach","item","Object","keys","$data","changedValue","positionGetValue","position","getValue","calcValueByPos","closestBound","getClosestBound","index","getBoundNeedMoving","prevValue","onStart","startValue","startPosition","prevMovedHandleIndex","onEnd","force","removeDocumentEvents","dragTrack","onMove","e","startBounds","pauseEvent","maxValue","minValue","pos","vertical","Math","ratio","getSliderLength","floor","c","oldValue","moveTo","onKeyboard","_this$$props","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","abs","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","marks","step","cache","internalPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","currentValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","ensureValueNotConflict","_ref2","getTrack","_ref3","included","offsets","trackStyle","slice","_","_classNames","trackClassName","concat","renderSlider","_this4","defaultHandle","handleStyle","handleGenerator","calcOffset","handleClassName","handles","_classNames2","mergedTabIndex","dragging","offset","style","ref","h","saveHandle","onFocus","onBlur","ariaLabel","ariaLabelledBy","ariaValueTextFormatter","tracks"],"sources":["/home/orange/Desktop/project-catalog-antd/node_modules/ant-design-vue/es/vc-slider/src/Range.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport { createVNode as _createVNode } from \"vue\";\nimport classNames from '../../_util/classNames';\nimport PropTypes, { withUndefined } from '../../_util/vue-types';\nimport BaseMixin from '../../_util/BaseMixin';\nimport { hasProp } from '../../_util/props-util';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nimport initDefaultProps from '../../_util/props-util/initDefaultProps';\nimport { defineComponent } from 'vue';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar rangeProps = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: Number,\n  pushable: withUndefined(PropTypes.oneOfType([PropTypes.looseBool, PropTypes.number])),\n  allowCross: {\n    type: Boolean,\n    default: undefined\n  },\n  disabled: {\n    type: Boolean,\n    default: undefined\n  },\n  reverse: {\n    type: Boolean,\n    default: undefined\n  },\n  tabindex: PropTypes.arrayOf(PropTypes.number),\n  prefixCls: String,\n  min: Number,\n  max: Number,\n  autofocus: {\n    type: Boolean,\n    default: undefined\n  },\n  ariaLabelGroupForHandles: Array,\n  ariaLabelledByGroupForHandles: Array,\n  ariaValueTextFormatterGroupForHandles: Array,\n  draggableTrack: {\n    type: Boolean,\n    default: undefined\n  }\n};\nvar Range = defineComponent({\n  name: 'Range',\n  mixins: [BaseMixin],\n  inheritAttrs: false,\n  props: initDefaultProps(rangeProps, {\n    count: 1,\n    allowCross: true,\n    pushable: false,\n    tabindex: [],\n    draggableTrack: false,\n    ariaLabelGroupForHandles: [],\n    ariaLabelledByGroupForHandles: [],\n    ariaValueTextFormatterGroupForHandles: []\n  }),\n  emits: ['beforeChange', 'afterChange', 'change'],\n  displayName: 'Range',\n  data: function data() {\n    var _this = this;\n\n    var count = this.count,\n        min = this.min,\n        max = this.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = hasProp(this, 'defaultValue') ? this.defaultValue : initialValue;\n    var value = this.value;\n\n    if (value === undefined) {\n      value = defaultValue;\n    }\n\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: _this.$props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    return {\n      sHandle: null,\n      recent: recent,\n      bounds: bounds\n    };\n  },\n  watch: {\n    value: {\n      handler: function handler(val) {\n        var bounds = this.bounds;\n        this.setChangeValue(val || bounds);\n      },\n      deep: true\n    },\n    min: function min() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    },\n    max: function max() {\n      var value = this.value;\n      this.setChangeValue(value || this.bounds);\n    }\n  },\n  methods: {\n    setChangeValue: function setChangeValue(value) {\n      var _this2 = this;\n\n      var bounds = this.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: bounds,\n          props: _this2.$props\n        });\n      });\n\n      if (bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: _this2.$props\n          });\n        });\n      }\n\n      this.setState({\n        bounds: nextBounds\n      });\n\n      if (value.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.$props);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.$props);\n        });\n        this.$emit('change', newValues);\n      }\n    },\n    onChange: function onChange(state) {\n      var isNotControlled = !hasProp(this, 'value');\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['sHandle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _extends(_extends({}, this.$data), state);\n\n      var changedValue = data.bounds;\n      this.$emit('change', changedValue);\n    },\n    positionGetValue: function positionGetValue(position) {\n      var bounds = this.getValue();\n      var value = this.calcValueByPos(position);\n      var closestBound = this.getClosestBound(value);\n      var index = this.getBoundNeedMoving(value, closestBound);\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[index] = value;\n      return nextBounds;\n    },\n    onStart: function onStart(position) {\n      var bounds = this.bounds;\n      this.$emit('beforeChange', bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        sHandle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    },\n    onEnd: function onEnd(force) {\n      var sHandle = this.sHandle;\n      this.removeDocumentEvents();\n\n      if (!sHandle) {\n        this.dragTrack = false;\n      }\n\n      if (sHandle !== null || force) {\n        this.$emit('afterChange', this.bounds);\n      }\n\n      this.setState({\n        sHandle: null\n      });\n    },\n    onMove: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.$data,\n          props = this.$props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n\n        return;\n      }\n\n      var bounds = this.bounds,\n          sHandle = this.sHandle;\n      var value = this.calcValueByPos(position);\n      var oldValue = bounds[sHandle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    },\n    onKeyboard: function onKeyboard(e) {\n      var _this$$props = this.$props,\n          reverse = _this$$props.reverse,\n          vertical = _this$$props.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var bounds = this.bounds,\n            sHandle = this.sHandle;\n        var oldValue = bounds[sHandle === null ? this.recent : sHandle];\n        var mutatedValue = valueMutator(oldValue, this.$props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: sHandle,\n          bounds: bounds,\n          props: this.$props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    },\n    getClosestBound: function getClosestBound(value) {\n      var bounds = this.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    },\n    getBoundNeedMoving: function getBoundNeedMoving(value, closestBound) {\n      var bounds = this.bounds,\n          recent = this.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    },\n    getLowerBound: function getLowerBound() {\n      return this.bounds[0];\n    },\n    getUpperBound: function getUpperBound() {\n      var bounds = this.bounds;\n      return bounds[bounds.length - 1];\n    },\n\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n    getPoints: function getPoints() {\n      var marks = this.marks,\n          step = this.step,\n          min = this.min,\n          max = this.max;\n      var cache = this.internalPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this.internalPointsCache.points;\n    },\n    moveTo: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var nextBounds = _toConsumableArray(this.bounds);\n\n      var sHandle = this.sHandle,\n          recent = this.recent;\n      var handle = sHandle === null ? recent : sHandle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (this.$props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (this.$props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        sHandle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.$emit('afterChange', nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    },\n    pushSurroundingHandles: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    },\n    pushHandle: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    },\n    pushHandleOnePoint: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n\n\n      bounds[handle] = nextValue;\n      return true;\n    },\n    trimAlignValue: function trimAlignValue(value) {\n      var sHandle = this.sHandle,\n          bounds = this.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: sHandle,\n        bounds: bounds,\n        props: this.$props\n      });\n    },\n    ensureValueNotConflict: function ensureValueNotConflict(handle, val, _ref2) {\n      var allowCross = _ref2.allowCross,\n          thershold = _ref2.pushable;\n      var state = this.$data || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.sHandle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n\n\n      return val;\n    },\n    getTrack: function getTrack(_ref3) {\n      var bounds = _ref3.bounds,\n          prefixCls = _ref3.prefixCls,\n          reverse = _ref3.reverse,\n          vertical = _ref3.vertical,\n          included = _ref3.included,\n          offsets = _ref3.offsets,\n          trackStyle = _ref3.trackStyle;\n      return bounds.slice(0, -1).map(function (_, index) {\n        var _classNames;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames = {}, _defineProperty(_classNames, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames));\n        return _createVNode(Track, {\n          \"class\": trackClassName,\n          \"vertical\": vertical,\n          \"reverse\": reverse,\n          \"included\": included,\n          \"offset\": offsets[i - 1],\n          \"length\": offsets[i] - offsets[i - 1],\n          \"style\": trackStyle[index],\n          \"key\": i\n        }, null);\n      });\n    },\n    renderSlider: function renderSlider() {\n      var _this4 = this;\n\n      var sHandle = this.sHandle,\n          bounds = this.bounds,\n          prefixCls = this.prefixCls,\n          vertical = this.vertical,\n          included = this.included,\n          disabled = this.disabled,\n          min = this.min,\n          max = this.max,\n          reverse = this.reverse,\n          handle = this.handle,\n          defaultHandle = this.defaultHandle,\n          trackStyle = this.trackStyle,\n          handleStyle = this.handleStyle,\n          tabindex = this.tabindex,\n          ariaLabelGroupForHandles = this.ariaLabelGroupForHandles,\n          ariaLabelledByGroupForHandles = this.ariaLabelledByGroupForHandles,\n          ariaValueTextFormatterGroupForHandles = this.ariaValueTextFormatterGroupForHandles;\n      var handleGenerator = handle || defaultHandle;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames2;\n\n        var mergedTabIndex = tabindex[i] || 0;\n\n        if (disabled || tabindex[i] === null) {\n          mergedTabIndex = null;\n        }\n\n        var dragging = sHandle === i;\n        return handleGenerator({\n          class: classNames((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames2, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames2)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabindex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          onFocus: _this4.onFocus,\n          onBlur: _this4.onBlur,\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      return {\n        tracks: this.getTrack({\n          bounds: bounds,\n          prefixCls: prefixCls,\n          reverse: reverse,\n          vertical: vertical,\n          included: included,\n          offsets: offsets,\n          trackStyle: trackStyle\n        }),\n        handles: handles\n      };\n    }\n  }\n});\nexport default createSlider(Range);"],"mappings":"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"},"metadata":{},"sourceType":"module"}