{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/home/orange/Desktop/project-catalog-antd/node_modules/@babel/runtime/helpers/slicedToArray.js\")[\"default\"];\n\nvar _toConsumableArray = require(\"/home/orange/Desktop/project-catalog-antd/node_modules/@babel/runtime/helpers/toConsumableArray.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.object.define-property.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.error.to-string.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _helperStringParser = require(\"@babel/helper-string-parser\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"./utils\");\n\nvar defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      \"default\": !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        var identifier = (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_constants.ASSIGNMENT_OPERATORS));\n        var pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          var validator = (0, _is[\"default\"])(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_constants.BINARY_OPERATORS))\n    },\n    left: {\n      validate: function () {\n        var expression = (0, _utils.assertNodeType)(\"Expression\");\n        var inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n        var validator = Object.assign(function (node, key, val) {\n          var validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      \"default\": []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function () {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(function () {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\nvar functionCommon = function functionCommon() {\n  return {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n    },\n    generator: {\n      \"default\": false\n    },\n    async: {\n      \"default\": false\n    }\n  };\n};\n\nexports.functionCommon = functionCommon;\n\nvar functionTypeAnnotationCommon = function functionTypeAnnotationCommon() {\n  return {\n    returnType: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    }\n  };\n};\n\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\n\nvar functionDeclarationCommon = function functionDeclarationCommon() {\n  return Object.assign({}, functionCommon(), {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  });\n};\n\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return function () {};\n    var identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is[\"default\"])(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\n\nvar patternLikeCommon = function patternLikeCommon() {\n  return {\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  };\n};\n\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier[\"default\"])(val, false)) {\n          throw new TypeError(\"\\\"\".concat(val, \"\\\" is not a valid identifier name\"));\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n  validate: function validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    var match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n\n    var _match = _slicedToArray(match, 2),\n        parentKey = _match[1];\n\n    var nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is[\"default\"])(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is[\"default\"])(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is[\"default\"])(\"Property\", parent, nonComp)) return;\n      if ((0, _is[\"default\"])(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is[\"default\"])(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is[\"default\"])(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is[\"default\"])(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(\"\\\"\".concat(node.name, \"\\\" is not a valid identifier\"));\n    }\n  }\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        var invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(\"\\\"\".concat(invalid[0], \"\\\" is not a valid RegExp flag\"));\n        }\n      }, {\n        type: \"string\"\n      })),\n      \"default\": \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_constants.LOGICAL_OPERATORS))\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\"].concat(_toConsumableArray(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])),\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\")\n    },\n    property: {\n      validate: function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        var validator = function validator(node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      \"default\": false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      \"default\": \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      \"default\": null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      \"default\": []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      \"default\": \"method\"\n    } : {}),\n    computed: {\n      \"default\": false\n    },\n    key: {\n      validate: function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        var validator = function validator(node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\"].concat(_toConsumableArray(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])),\n  fields: {\n    computed: {\n      \"default\": false\n    },\n    key: {\n      validate: function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n        var validator = Object.assign(function (node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is[\"default\"])(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      \"default\": false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    var pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"TSAsExpression\", \"TSNonNullExpression\", \"TSTypeAssertion\");\n    var expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      var validator = (0, _is[\"default\"])(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon(), {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n  validate: function validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    var match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n\n    var _match2 = _slicedToArray(match, 3),\n        listKey = _match2[1],\n        index = _match2[2];\n\n    if (parent[listKey].length > +index + 1) {\n      throw new TypeError(\"RestElement must be last element of \".concat(listKey));\n    }\n  }\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      \"default\": true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_constants.UNARY_OPERATORS))\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      \"default\": false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf).apply(void 0, _toConsumableArray(_constants.UPDATE_OPERATORS))\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n  validate: function validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is[\"default\"])(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(\"Exactly one VariableDeclarator is required in the VariableDeclaration of a \".concat(parent.type));\n    }\n  }\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        var normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        var without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          var validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\", \"LVal\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"ClassAccessorProperty\", \"TSDeclareMethod\", \"TSIndexSignature\", \"StaticBlock\")))\n    }\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    \"implements\": {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    \"implements\": {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    \"abstract\": {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    var identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is[\"default\"])(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"TSDeclareFunction\", \"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      \"default\": [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        var sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        var sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          var validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        var declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        var lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\");\n        return function (node, key, val) {\n          if ((0, _is[\"default\"])(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    \"await\": {\n      \"default\": false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        var property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is[\"default\"])(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\nvar classMethodOrPropertyCommon = function classMethodOrPropertyCommon() {\n  return {\n    \"abstract\": {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    accessibility: {\n      validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n      optional: true\n    },\n    \"static\": {\n      \"default\": false\n    },\n    override: {\n      \"default\": false\n    },\n    computed: {\n      \"default\": false\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    key: {\n      validate: (0, _utils.chain)(function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\"))\n    }\n  };\n};\n\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\n\nvar classMethodOrDeclareMethodCommon = function classMethodOrDeclareMethodCommon() {\n  return Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {\n    params: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n      \"default\": \"method\"\n    },\n    access: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  });\n};\n\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      }), function templateElementCookedValidator(node) {\n        var raw = node.value.raw;\n        var str,\n            containsInvalid,\n            unterminatedCalled = false;\n\n        try {\n          var error = function error() {\n            throw new Error();\n          };\n\n          var _ref = (0, _helperStringParser.readStringContents)(\"template\", raw, 0, 0, 0, {\n            unterminated: function unterminated() {\n              unterminatedCalled = true;\n            },\n            strictNumericEscape: error,\n            invalidEscapeSequence: error,\n            numericSeparatorInEscapeSequence: error,\n            unexpectedNumericSeparator: error,\n            invalidDigit: error,\n            invalidCodePoint: error\n          });\n\n          str = _ref.str;\n          containsInvalid = _ref.containsInvalid;\n        } catch (_unused) {\n          unterminatedCalled = true;\n          containsInvalid = true;\n        }\n\n        if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n        node.value.cooked = containsInvalid ? null : str;\n      })\n    },\n    tail: {\n      \"default\": false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(\"Number of \".concat(node.type, \" quasis should be exactly one more than the number of expressions.\\nExpected \").concat(val.length + 1, \" quasis but got \").concat(node.quasis.length));\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      \"default\": false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n        var validator = Object.assign(function (node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\"]\n        });\n        return validator;\n      }()\n    },\n    computed: {\n      \"default\": false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\", \"Accessor\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    key: {\n      validate: (0, _utils.chain)(function () {\n        var normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"PrivateName\");\n        var computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          var validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\", \"PrivateName\"))\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    \"static\": {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      \"default\": false\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\"),\n      \"default\": \"method\"\n    },\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","patternLikeCommon","functionTypeAnnotationCommon","functionDeclarationCommon","functionCommon","classMethodOrPropertyCommon","classMethodOrDeclareMethodCommon","_is","require","_isValidIdentifier","_helperValidatorIdentifier","_helperStringParser","_constants","_utils","defineType","defineAliasedType","fields","elements","validate","chain","assertValueType","assertEach","assertNodeOrValueType","process","env","BABEL_TYPES_8_BREAKING","undefined","visitor","aliases","operator","identifier","assertOneOf","ASSIGNMENT_OPERATORS","pattern","node","key","val","validator","left","assertNodeType","right","builder","BINARY_OPERATORS","expression","inOp","assign","oneOfNodeTypes","directives","body","label","optional","callee","arguments","typeArguments","typeParameters","param","test","consequent","alternate","program","comments","each","tokens","type","init","update","params","generator","async","returnType","declare","id","predicate","parent","inherits","typeAnnotation","decorators","name","TypeError","match","exec","parentKey","nonComp","computed","imported","meta","isKeyword","isReservedWord","deprecatedAlias","flags","invalid","LOGICAL_OPERATORS","object","property","normal","sourceFile","sourceType","interpreter","properties","kind","shorthand","argument","Error","listKey","index","length","expressions","discriminant","cases","block","handler","finalizer","prefix","UNARY_OPERATORS","UPDATE_OPERATORS","declarations","without","definite","superClass","superTypeParameters","mixins","source","exportKind","validateOptional","assertions","declaration","specifiers","sourced","sourceless","local","exported","lval","importKind","accessibility","override","access","tag","quasi","assertShape","raw","cooked","templateElementCookedValidator","str","containsInvalid","unterminatedCalled","error","readStringContents","unterminated","strictNumericEscape","invalidEscapeSequence","numericSeparatorInEscapeSequence","unexpectedNumericSeparator","invalidDigit","invalidCodePoint","_unused","tail","quasis","delegate","assertOptionalChainStart","readonly","variance"],"sources":["/home/orange/Desktop/project-catalog-antd/node_modules/@babel/types/lib/definitions/core.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.patternLikeCommon = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\n\nvar _is = require(\"../validators/is\");\n\nvar _isValidIdentifier = require(\"../validators/isValidIdentifier\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _helperStringParser = require(\"@babel/helper-string-parser\");\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"./utils\");\n\nconst defineType = (0, _utils.defineAliasedType)(\"Standardized\");\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"Expression\", \"SpreadElement\"))),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertValueType)(\"string\");\n        }\n\n        const identifier = (0, _utils.assertOneOf)(..._constants.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)(\"=\");\n        return function (node, key, val) {\n          const validator = (0, _is.default)(\"Pattern\", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }()\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)(\"Expression\");\n        const inOp = (0, _utils.assertNodeType)(\"Expression\", \"PrivateName\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.operator === \"in\" ? inOp : expression;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"DirectiveLiteral\")\n    }\n  }\n});\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  }\n});\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\"]\n});\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Expression\", \"Conditional\"]\n});\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    }\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"DoWhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"]\n});\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)(\"Program\")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: [\"CommentBlock\", \"CommentLine\"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)(\"CommentBlock\", \"CommentLine\")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: \"any\"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\") : (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)(\"VariableDeclaration\", \"Expression\"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\n\nconst functionCommon = () => ({\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\")))\n  },\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n});\n\nexports.functionCommon = functionCommon;\n\nconst functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n    optional: true\n  }\n});\n\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\n\nconst functionDeclarationCommon = () => Object.assign({}, functionCommon(), {\n  declare: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)(\"Identifier\"),\n    optional: true\n  }\n});\n\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  }),\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pureish\", \"Declaration\"],\n  validate: function () {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return () => {};\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\n\nconst patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\n\nexports.patternLikeCommon = patternLikeCommon;\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\"],\n  aliases: [\"Expression\", \"PatternLike\", \"LVal\", \"TSEntityName\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    name: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`\"${val}\" is not a valid identifier name`);\n        }\n      }, {\n        type: \"string\"\n      }))\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n\n    if (parentKey === \"property\") {\n      if ((0, _is.default)(\"MemberExpression\", parent, nonComp)) return;\n      if ((0, _is.default)(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if ((0, _is.default)(\"Property\", parent, nonComp)) return;\n      if ((0, _is.default)(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if ((0, _is.default)(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if ((0, _is.default)(\"ImportSpecifier\", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === \"meta\") {\n      if ((0, _is.default)(\"MetaProperty\", parent, {\n        meta: node\n      })) return;\n    }\n\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== \"this\") {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  }\n\n});\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"number\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    flags: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        const invalid = /[^gimsuy]/.exec(val);\n\n        if (invalid) {\n          throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n        }\n      }, {\n        type: \"string\"\n      })),\n      default: \"\"\n    }\n  }\n});\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"optional\"] : [])],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"Super\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertOneOf)(true, false),\n      optional: true\n    }\n  } : {})\n});\ndefineType(\"NewExpression\", {\n  inherits: \"CallExpression\"\n});\ndefineType(\"Program\", {\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceFile: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    },\n    sourceType: {\n      validate: (0, _utils.assertOneOf)(\"script\", \"module\"),\n      default: \"script\"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)(\"InterpreterDirective\"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Directive\"))),\n      default: []\n    },\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"]\n});\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ObjectMethod\", \"ObjectProperty\", \"SpreadElement\")))\n    }\n  }\n});\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)(\"method\", \"get\", \"set\")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: \"method\"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }),\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"UserWhitespacable\", \"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"ObjectMember\"]\n});\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...(!process.env.BABEL_TYPES_8_BREAKING ? [\"decorators\"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"DecimalLiteral\", \"PrivateName\"]\n        });\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\", \"PatternLike\")\n    },\n    shorthand: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.computed) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if computed is true\");\n        }\n      }, {\n        type: \"boolean\"\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !(0, _is.default)(\"Identifier\", node.key)) {\n          throw new TypeError(\"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\");\n        }\n      }),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: function () {\n    const pattern = (0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"TSAsExpression\", \"TSNonNullExpression\", \"TSTypeAssertion\");\n    const expression = (0, _utils.assertNodeType)(\"Expression\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n      const validator = (0, _is.default)(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  }()\n});\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"LVal\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: Object.assign({}, patternLikeCommon(), {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"LVal\") : (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  }),\n\n  validate(parent, key) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n    const [, listKey, index] = match;\n\n    if (parent[listKey].length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  }\n\n});\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\")))\n    }\n  },\n  aliases: [\"Expression\"]\n});\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    consequent: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  }\n});\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    cases: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"SwitchCase\")))\n    }\n  }\n});\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"BlockStatement\"), Object.assign(function (node) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError(\"TryStatement expects either a handler or finalizer, or both\");\n        }\n      }, {\n        oneOfNodeTypes: [\"BlockStatement\"]\n      }))\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"CatchClause\")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  }\n});\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UNARY_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)(\"Expression\") : (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._constants.UPDATE_OPERATORS)\n    }\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"var\", \"let\", \"const\")\n    },\n    declarations: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"VariableDeclarator\")))\n    }\n  },\n\n  validate(parent, key, node) {\n    if (!process.env.BABEL_TYPES_8_BREAKING) return;\n    if (!(0, _is.default)(\"ForXStatement\", parent, {\n      left: node\n    })) return;\n\n    if (node.declarations.length !== 1) {\n      throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n    }\n  }\n\n});\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"LVal\");\n        }\n\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\");\n        const without = (0, _utils.assertNodeType)(\"Identifier\");\n        return function (node, key, val) {\n          const validator = node.init ? normal : without;\n          validator(node, key, val);\n        };\n      }()\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    }\n  }\n});\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\"],\n  builder: [\"left\", \"right\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    left: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"ObjectPattern\", \"ArrayPattern\", \"MemberExpression\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)(\"null\", \"PatternLike\", \"LVal\")))\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    optional: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pureish\"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    expression: {\n      validate: (0, _utils.assertValueType)(\"boolean\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\", \"Expression\")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ClassMethod\", \"ClassPrivateMethod\", \"ClassProperty\", \"ClassPrivateProperty\", \"ClassAccessorProperty\", \"TSDeclareMethod\", \"TSIndexSignature\", \"StaticBlock\")))\n    }\n  }\n});\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterDeclaration\", \"TSTypeParameterDeclaration\", \"Noop\"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"ClassBody\")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TSExpressionWithTypeArguments\", \"ClassImplements\"))),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)(\"InterfaceExtends\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    }\n  },\n  validate: function () {\n    const identifier = (0, _utils.assertNodeType)(\"Identifier\");\n    return function (parent, key, node) {\n      if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n      if (!(0, _is.default)(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  }()\n});\ndefineType(\"ExportAllDeclaration\", {\n  visitor: [\"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\")),\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    }\n  }\n});\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      validate: (0, _utils.assertNodeType)(\"TSDeclareFunction\", \"FunctionDeclaration\", \"ClassDeclaration\", \"Expression\")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"value\"))\n  }\n});\ndefineType(\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Declaration\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.specifiers.length) {\n          throw new TypeError(\"Only declaration or specifiers is allowed on ExportNamedDeclaration\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Declaration\"]\n      }), function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && node.source) {\n          throw new TypeError(\"Cannot export a declaration from a source\");\n        }\n      })\n    },\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      default: [],\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)(function () {\n        const sourced = (0, _utils.assertNodeType)(\"ExportSpecifier\", \"ExportDefaultSpecifier\", \"ExportNamespaceSpecifier\");\n        const sourceless = (0, _utils.assertNodeType)(\"ExportSpecifier\");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        };\n      }()))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)(\"type\", \"value\"))\n  }\n});\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)(\"VariableDeclaration\", \"LVal\");\n        }\n\n        const declaration = (0, _utils.assertNodeType)(\"VariableDeclaration\");\n        const lval = (0, _utils.assertNodeType)(\"Identifier\", \"MemberExpression\", \"ArrayPattern\", \"ObjectPattern\", \"TSAsExpression\", \"TSTypeAssertion\", \"TSNonNullExpression\");\n        return function (node, key, val) {\n          if ((0, _is.default)(\"VariableDeclaration\", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        };\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"Statement\")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType(\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"],\n  fields: {\n    assertions: {\n      optional: true,\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportAttribute\")))\n    },\n    specifiers: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\")))\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)(\"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)(\"type\", \"typeof\", \"value\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: (0, _utils.chain)((0, _utils.assertNodeType)(\"Identifier\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n        let property;\n\n        switch (val.name) {\n          case \"function\":\n            property = \"sent\";\n            break;\n\n          case \"new\":\n            property = \"target\";\n            break;\n\n          case \"import\":\n            property = \"meta\";\n            break;\n        }\n\n        if (!(0, _is.default)(\"Identifier\", node.property, {\n          name: property\n        })) {\n          throw new TypeError(\"Unrecognised MetaProperty\");\n        }\n      }, {\n        oneOfNodeTypes: [\"Identifier\"]\n      }))\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\n\nconst classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)(\"boolean\"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\");\n      const computed = (0, _utils.assertNodeType)(\"Expression\");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\"))\n  }\n});\n\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\n\nconst classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {\n  params: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Identifier\", \"Pattern\", \"RestElement\", \"TSParameterProperty\")))\n  },\n  kind: {\n    validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"string\"), (0, _utils.assertOneOf)(\"public\", \"private\", \"protected\")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n    optional: true\n  }\n});\n\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\", \"generator\", \"async\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"properties\"],\n  aliases: [\"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    properties: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"RestElement\", \"ObjectProperty\")))\n    }\n  })\n});\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Super\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\", \"typeParameters\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)(\"TemplateLiteral\")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\", \"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)(\"string\")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)(\"string\"),\n          optional: true\n        }\n      }), function templateElementCookedValidator(node) {\n        const raw = node.value.raw;\n        let str,\n            containsInvalid,\n            unterminatedCalled = false;\n\n        try {\n          const error = () => {\n            throw new Error();\n          };\n\n          ({\n            str,\n            containsInvalid\n          } = (0, _helperStringParser.readStringContents)(\"template\", raw, 0, 0, 0, {\n            unterminated() {\n              unterminatedCalled = true;\n            },\n\n            strictNumericEscape: error,\n            invalidEscapeSequence: error,\n            numericSeparatorInEscapeSequence: error,\n            unexpectedNumericSeparator: error,\n            invalidDigit: error,\n            invalidCodePoint: error\n          }));\n        } catch (_unused) {\n          unterminatedCalled = true;\n          containsInvalid = true;\n        }\n\n        if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n        node.value.cooked = containsInvalid ? null : str;\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"TemplateElement\")))\n    },\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"TSType\")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), Object.assign(function (node, key, val) {\n        if (!process.env.BABEL_TYPES_8_BREAKING) return;\n\n        if (val && !node.argument) {\n          throw new TypeError(\"Property delegate of YieldExpression cannot be true if there is no argument\");\n        }\n      }, {\n        type: \"boolean\"\n      })),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    }\n  }\n});\ndefineType(\"Import\", {\n  aliases: [\"Expression\"]\n});\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)(\"string\")\n    }\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"]\n});\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: [\"Expression\", \"Identifier\"]\n        });\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"arguments\", \"typeParameters\", \"typeArguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)(\"Expression\")\n    },\n    arguments: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Expression\", \"SpreadElement\", \"JSXNamespacedName\", \"ArgumentPlaceholder\")))\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)(\"boolean\") : (0, _utils.chain)((0, _utils.assertValueType)(\"boolean\"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)(\"TypeParameterInstantiation\"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)(\"TSTypeParameterInstantiation\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  builder: [\"key\", \"value\", \"typeAnnotation\", \"decorators\", \"computed\", \"static\"],\n  aliases: [\"Property\", \"Accessor\"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    key: {\n      validate: (0, _utils.chain)(function () {\n        const normal = (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"PrivateName\");\n        const computed = (0, _utils.assertNodeType)(\"Expression\");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)(\"Identifier\", \"StringLiteral\", \"NumericLiteral\", \"BigIntLiteral\", \"Expression\", \"PrivateName\"))\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  })\n});\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"key\", \"value\", \"decorators\", \"typeAnnotation\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)(\"Expression\"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)(\"TypeAnnotation\", \"TSTypeAnnotation\", \"Noop\"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Decorator\"))),\n      optional: true\n    },\n    static: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      default: false\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)(\"boolean\"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)(\"Variance\"),\n      optional: true\n    }\n  }\n});\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\"key\", \"params\", \"body\", \"decorators\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\", \"Private\"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)(\"get\", \"set\", \"method\"),\n      default: \"method\"\n    },\n    key: {\n      validate: (0, _utils.assertNodeType)(\"PrivateName\")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)(\"BlockStatement\")\n    }\n  })\n});\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)(\"Identifier\")\n    }\n  }\n});\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)(\"array\"), (0, _utils.assertEach)((0, _utils.assertNodeType)(\"Statement\")))\n    }\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"]\n});"],"mappings":"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"},"metadata":{},"sourceType":"script"}